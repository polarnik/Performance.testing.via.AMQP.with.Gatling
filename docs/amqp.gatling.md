Название доклада:
Тестирование производительности по протоколу AMQP с Gatling
 
Описание:
Доклад о разработке плагинов для Gatling и тестировании производительности через RabbitMQ, о решении технических проблем и создании новых.

Рассказ основан на опыте команды Raiffeisen Business Platform по тестированию производительности асинхронных микросервисов, которые принимают запросы через RabbitMQ по протоколу AMQP и отвечают также в RabbitMQ.

В качестве инструмента для подачи нагрузки был выбран Gatling. И в ходе написания тестов были решены следующие технические проблемы:
- Как подать нагрузку через RabbitMQ, когда нет плагина для AMQP?
- Как написать оптимальный Gatling-сценарий, который не будет потреблять гигабайты оперативной памяти?
- Как эффективно замерить длительность от момента отправки сообщения в одну очередь, до момента появления сообщения в другой очереди и не забыть момент появления сообщения во временной очереди?
- Как логировать асинхронные операции, какой подход выбрать для разделения десятка сценариев в рамках одного Gatling-теста?
 
Детальный план доклада:
О себе и Raiffeisen Business Platform.
Занимаюсь тестированием производительности. В команде RBP, которая разрабатывает сервисы для каналов ДБО для юридических лиц. Сервисов много.

Стек технологий
Linux, Scala, RabbitMQ, PostgreSQL — распространённые составляющие тестируемых сервисов.

Чем подавать нагрузку
Плагины AMQP для Apache.JMeter 5.1+ — устарели, необходима доработка почти для всех. Нужно писать код на Java.
Плагины AMQP для Gatling 3.0+ — устарели и клиент для RabbitMQ изменился сильно. Нужно писать новый код на Scala.
Выбрали Gatling и решили написать для него новый плагин.

Разработка Gatling-плагина
Как можно отправить AMQP-запрос из Gatling без плагина — нагрузка подаётся, но метрики в отчет не попадают.
Зачем нужен плагин для Gatling? — DSL-синтаксис для написания сценария и метрики попадают в отчёт.
Что взять за основу при написании плагина для Gatling? — существующие плагины: JMS, HTTP, JDBC. И старую версию AMQP-плагина.
Какие плагины получились в результате разработки: ссылка на проект

Архитектура AMQP-клиента и сервера
Если использовать CorrelationID для ожидания ответов от сервера, то на стороне нагрухочного сценария или реального клиента будет скапливаться большое количество объектов, реализующих ожидание ответа. И на Gatling/клиент сервиса начинает потреблять много оперативной памяти. Поэтому в сервисе не используется CorrelationID.

Архитектура Gatling-сценария для работы с AMQP
Если использовать CorrelationID — закончится память.
Отправка запроса и получение ответа реализуются в разных сценариях, связанных через HashMap с сообщениями.
До теста нужно очищать очереди.
После теста нужно логировать задачи, которые не успели обработаться за тест.
Для измерения длительности между моментами отправки запроса в одном сценарии до момента получения ответа в другом сценарии реализован дополнительный плагин логирования асинхронных операций.

Внутренний механизм корреляции сообщений
Есть разные варианты реализации:
* передавать вместо значения CorrelationID callback-функцию, которая будет реализовывать логику корреляции, как в JMS-плагине
* реализовать механизм корреляции через механизм работы с сессией
* реализовать механизм внутренней корреляции прямо в Gatling-плагине

Описание реализованного AMQP-плагина для Gatling 3.0+
Что было сделано.
Что не было сделано.
Примеры кода

Описание плагина для логирования асинхронных операций в Gatling
Что было сделано.
Что не было сделано.
Примеры кода

Использование группировки событий в Gatling
Какие есть сложности при группировке событий в Gatling — по умолчанию статистика по группам сохраняется в Graphite с ошибками и не отображается в Grafana, и это можно исправить: {ссылка на инструкцию и готовую доску Grafana}. А в html-отчёте всё работает.
Варианты группировки событий в Gatling для html-отчёта.
Варианты группировки событий в Gatling для Grafana-отчёта.

Ссылки, источники, основная мысль
Разрабатывать плагины для Gatling — здорово!

